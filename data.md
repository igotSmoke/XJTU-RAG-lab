---
title: 'FAQ'
category: 'faq'
---

# 常见问题

## 1.磁盘的基本结构是什么？

​盘片组​：多个盘片垂直堆叠，通过转轴高速旋转，每个盘面对应一个磁头，所有磁头固定在同一磁头臂上同步移动。
盘面：一个盘片是盘面
​磁道与扇区​：盘面被划分为同心圆磁道，磁道进一步分割为扇区​（最小寻址单位）。
​柱面​：所有盘面同一半径的磁道组成柱面，是减少磁头移动的关键结构。

## 2.传统磁盘有什么缺陷？

​固定扇区数设计​：早期磁盘将所有磁道划分为相同数量的扇区（如图5.18所示）。由于内圈磁道周长较短，其位密度（每英寸存储的比特数）必须远高于外圈磁道才能容纳相同数据量。
​容量浪费​：外圈磁道物理长度更长，但扇区数与内圈相同，导致外圈存储空间未被充分利用。

## 3.现代磁盘相比与传统磁盘做出了哪些改进？

分区域记录（ZBR）​​
​环带划分​：将盘面划分为多个同心圆环带（Zone），每个环带包含若干相邻磁道。
​动态扇区分配​：
​同一环带内​：所有磁道扇区数相同（如图中“环带1”和“环带2”）。
​不同环带间​：外层环带的磁道扇区数多于内层（例如，外圈环带每磁道16个扇区，内圈环带仅12个）。

## 4.磁盘的物理地址表示是什么？

磁盘地址由三元组 柱面号·盘面号·扇区号​ 唯一标识，容量由柱面数、盘面数和扇区数决定。（先柱面再盘面）

## 5.磁盘有哪些分类？

1.​按磁头设计​
​固定头磁盘​：每个磁道独立磁头，速度快但成本高（用于高性能场景）。
​活动头磁盘​：磁头臂移动定位磁道（如温彻斯特磁盘，现代HDD主流设计）。
2.​按盘片可更换性​
​固定盘磁盘​：盘片不可拆卸（如内置硬盘）。
​可换盘磁盘​：盘片可替换（早期存储设备，如软盘）。

## 6.DBMS存储的基本结构是什么？

索引：由数据库表记录到磁盘块的映射
由操作系统的文件管理系统（FAT）寻找磁盘块号
内存和磁盘块的映射
缓冲区的作用：内存中存储磁盘块的拷贝内容。一般采用LRU进行替换
查询-》索引——》内存块-》内存、缓冲区-》磁盘（I/O）

## 7.DBMS记录的磁盘存储分哪几种？

单调记录存储
非跨块存储：浪费一些空间，但磁盘之间无关联，可并行
跨块存储：磁盘之间有关联，不可并行

## 8.文件组织指什么？
文件组织(File Organization)指的是数据组织成记录、块和访问结构的方式，包括把记录和块存储在磁盘上的方式，以及记录和块之间相互联系的方法。

## 9.存取方法指什么？
存取方法指对文件所采取的存取操作方法。

## 10.文件组织方法有哪几种

1.无序文件组织（堆文件方式）：如果查询性能下降，需要周期性重组数据（类似数组移动）
2.顺序件组织：只有按照排序码检索时才会提高速度，更新低
3. 散列文件（hash 文件）
4. 聚簇文件（cluster）:可以提高查询速度

## 11.文件组织方法中的无序记录文件指什么？

记录可存储于任意有空间的位置。
1.方法1 新纪录总插入到文件尾部；删除记录时，可以直接删除该记录所在位置的内容，也可以在该记录前标记”删除标记"
2.方法2 在方法1的基础上，新增记录可以利用那些标记为删除标记的记录空间

## 12.文件组织方法中的有序记录文件指什么？

记录按属性或属性组值的顺序插入，磁盘上存储的记录是有序的。
用于存储排序的属性通常称为排序字段。

## 13.文件组织方法中的散列文件指什么？

可以把记录按某属性或某属性组的值，依据一个散列函数来计算其相应存放的位置：桶号。检索效率和更新效率都有一定程度的提高。

## 14.文件组织方法中的聚簇文件指什么？

将具有相同或相似属性值的记录存放于连续的磁盘块中。

## 15.数据库中的表对应的存储形式？数据在磁盘中存储组织的形式？记录的存储形式？

数据库由多个文件组成，每个文件包含多个块（每个块的大小4-8KB），每个块包含多条记录，数据以记录的形式被承载；记录又可以分为定长记录以及变长记录：

定长记录：记录包括首部以及记录内容
首部：记录元信息的指针（chema）；记录长度；时间戳
记录的元信息格式：字段的数量；每个字段的类型；字段在记录中的顺序；每个字段的名称
通过元信息的指针可以找到记录的 schema 对读取到的记录 buffer 进行解析；通过记录长度可以知道要读取的buffer的尾部位置

记录在块中存储的方式，记录的元信息（记录的首地址，记录的长度）从低地址往后增长，记录本身从块的尾部向前存放，使用一种叫做 slotted-page structure的方式在块中组织记录，块头主要包含以下信息：
记录数
空闲空间指针
记录数组entries（记录偏移，记录长度）
记录从块的尾部往前放，在header aray的尾部和第一个记录首部之间的空间称为 free space（空闲空间），用来存放新插入的记录以及新的entry。

## 16.具有变长字段的记录以什么格式存储？

记录的存储格式为 <首部信息（schema/时间戳），记录长度，变长字段的指针，变长字段的长度， ... ，非变长字段数据内容，... ，变成字段内容 ... >。其中第一个非变长字段的指针无需存储，可以通过 schema 的信息计算偏移得到。 变长字段通过 <offset, length> 进行标识

## 17.可变格式的记录以什么格式存储？

可变格式的记录中，一个块中存储的记录可能存在不同的 schema，因此需要将每个记录的字段元信息和记录本身存储在一起，包括字段数据类型、字段长度

## 18.不能装入一个块中的记录以什么格式存储？

在每个记录的起始位置处记录一个指针，指向它的上一个/下一个块的记录部分。

## 19.记录存储在磁盘中，访问每条记录的地址形式的什么样的？

拿磁盘索引B+ 树举例，索引中的每个节点通常是以page为单位在磁盘中进行存储。当从磁盘中读取一个节点后，需要根据当前节点读取它的孩子节点，可以通过记录 pageId 的形式将每个孩子节点的地址存储在父节点中。

## 20.指针混写是什么？

数据块从磁盘读取到内存前，数据块中需要保存每个孩子节点的 pageId；当数据块从磁盘读取到内存后，可以使用虚拟地址进行访问，减少查页表时对pageId进行地址转换

## 21.指针混写的目的是什么？

避免将数据库地址（pageId）重复转换成内存地址的开销

## 22.指针混写的思想是什么？

当将数据块从磁盘读取到主存时，块内指针可以混写，即从数据库地址空间转换为虚拟地址空间

## 23.指针混写有哪些策略？
1.自动混写2.按需混写：根据数据块使用频率确定是否需要混写3.不混写

## 24.指针混写中，被钉住的记录与块该怎么理解？

可以继续使用磁盘索引 B+ 树的例子进行理解，当新增了一个叶子节点后，叶子节点刷入磁盘后，才能知道它的数据库地址(pageId），在这之后它的父节点的孩子节点指针才能被正确更新并写到磁盘，否则父节点都不能被写磁盘，因为它的孩子节点地址是无效的。

## 25.修改如何写入磁盘？（新增、修改、删除）

1.插入：
记录没有特性的顺序：将新纪录插入到块的空闲位置或是已删除记录的地方
记录有特定的顺序：如果邻近块有空闲空间，则移动记录到邻近块即可；否则，创建一个溢出块
2.删除：
及时回收空间
标记删除
3.修改：
定长记录：对存储无影响
变长记录：相当于删除原纪录，插入新纪录，方法和插入与修改的方向一样

## 26.什么是索引？

索引是一种用于提高数据库表中数据检索效率的数据结构，将原本无规则一行一行排列的原始数据按照特定的数据结构排列起来而形成一个新的排序+原始数据的结构。这种数据结构主要以「平衡树」(非二叉)，也就是b tree或者 b+ tree为主，当然有的数据库也使用哈希桶作用索引的数据结构。

## 27.索引的作用是什么？

1.提高查询速度‌：如果没有索引，通常会全表扫描数据，如果表的数据非常大的话，一条一条的去匹配的话，最坏的情况下需要匹配O(n)最坏时间复杂度；而通过索引的话，不需要全表扫描，一般只需要O(logn)次就可以定位到具体的数据，大大减少了查询速度。
2.加速排序和分组‌：索引可以优化ORDER BY和GROUP BY操作，MySQL可以利用索引中已经排序的数据，避免额外的排序操作‌。
3.‌优化连接查询‌：索引还可以提高JOIN操作的效率，使得连接查询更加快速‌。
4.管理数据库约束。索引通常还会用于数据库约束，例如：UNIQUE，PRIMARY KEY，FOREIG KEY，当一个索引被定义成UNIQUE时，数据库同时创建一个隐式的约束。

## 28.索引的缺点是什么？

1.索引本身需要存储空间，特别是对于大型表，索引文件可能会占用大量的磁盘空间，从而增加了存储成本‌；
2.索引会影响写操作的性能。当对表进行插入、更新或删除操作时，索引也需要相应地进行维护，这会增加这些操作的时间开销。在高并发写入的场景下，性能可能会显著下降‌；
3.索引的维护也需要额外的开销。随着数据的不断变化，索引可能会变得不再高效，需要定期进行重建或优化。在数据频繁变化的场景下，维护索引可能会成为性能瓶颈‌。

## 29.索引按照物理数据的存储位置分为什么？

1.聚集索引：聚集索引中所有的物理数据都会存放到聚集索引的叶子节点上，即：只要找到叶子节点，就能好从叶子节点上获取到想要的物理数据。在InnoDB引擎中一个表只能有一个聚集索引，一般都是使用主键索引来作为聚集索引，如果没有创建主键，则mysql会默认创建一个主键索引。除此之外其他索引都为辅助索引，也可以叫二级索引，辅助索引的叶子节点存放的是对应行数据的主键id。
2.非聚集索引：在非聚集索引中物理数据与索引是分开的，非聚簇索引的叶子节点都不存放具体的物理数据而是存放的指向具体物理数据对应行的指针。而在MyISAM引擎中所有的索引（包括主键索引）都是非聚集索引。

## 30.索引的创建方式有哪些？

--1、主键索引：即根据主键pk_clolum（length）建立索引，不允许重复；
ALTER TABLE table_name ADD PRIMARY KEY index_name(id);
--2、唯一索引：用来建立索引的列的值必须是唯一的，允许空值；
ALTER TABLE table_name ADD UNIQUE index_name(col1(10));
--3、普通索引：用表中的普通列构建的索引，没有任何限制；
ALTER TABLE table_name ADD INDEX index_name(col2(20);
--4、全文索引：用大文本对象的列构建的索引；
ALTER TABLE table_name ADD FULLTEXT INDEX index_name(col3(255));
--5、组合索引：用多个列组合构建的索引；
ALTER TABLE table_name ADD INDEX index_name(col1,col2,col3)；
--删除索引
ALTER  TABLE  company  DROP  INDEX  index_name;

## 31.索引的底层数据结构是什么？

索引常用的数据结构主要有B-tree（平衡树）、B+tree、Hashes（哈希）。

## 32.B+tree与B-tree的主要区别在于什么？

1.节点存储内容的不同‌：
B+tree中，非叶节点只存储关键字和子节点的引用，不保存物理数据；所有的物理数据都保存在叶子节点中‌‌。
B-tree中，每个节点都存储关键字和对应的物理数据。
2.树的高度差异‌：
由于B+tree的非叶节点不存储数据，只存储关键字和索引，因此每个节点可以容纳更多的元素，这导致B+tree的树高比B-tree小。
由于B-tree中，每个节点都存储关键字和对应的物理数据，导致每个节点存放的元素更少，树的高度也更高。
3.叶子节点的特性‌：
B+tree的叶子节点是顺序排列的，并且相邻节点具有顺序引用关系，形成一个有序的链表，这支持高效的范围查询和顺序遍历‌‌。
B-tree的叶子节点虽然也位于同一层，但并不具备这种顺序引用关系‌‌。
4.查询性能的差异‌：
在B+tree中，由于所有记录都在叶子节点，每个记录的查找时间基本相同，查询速度更稳定，都需要从根节点走到叶子节点，并在叶子节点中比较关键字。并且由于B+tree的树高比B-tree小，从而减少了磁盘的访问次数，使得在实际应用中B+树的性能往往更好‌‌。
在B-tree中，越靠近根节点的记录查找时间越快，找到关键字即可确定记录的存在‌。


## 33. InnoDB索引实现是什么？

InnoDB引擎使用B+Tree作为索引实现，所有的物理数据都会存储在主键索引的叶子节点上，通过主键索引可以直接在叶子节点上获取到具体的物理数据。而通过辅助索引在叶子节点上只能拿到获取具体数据的主键id，然后再通过主键去查找主键索引，最终从主键索引的叶子节点上找到具体的物理数据。

## 34.MslSAM索引实现是什么？

MyISAM引擎也是使用B+Tree作为索引实现，并且所有的索引都是非聚集索引。在MyISAM引擎中都是先通过索引找到指向具体数据的指针，再通过指针找到具体的数据。

## 35.联合索引最左匹配原则的原理是什么？

联合索引最左原则的原理是：在创建联合索引时，索引的排序和存储是按照从左到右的顺序进行的，因此在查询时也必须遵循这一顺序，从联合索引的最左边开始匹配，才能有效利用索引‌。如果查询条件中不包含最左列，那么索引将无法被有效利用，可能导致查询性能下降‌。

## 36.联合索引的优点有哪些？

1.减少存储空间‌：与单个索引相比，联合索引将多个列组合在一起，可以避免创建多个单独的索引，从而减少存储空间的消耗‌。
2.‌提高数据完整性‌：联合索引可以为表中的多个列同时设置唯一性约束，确保数据的完整性和一致性。如果业务要求两个或更多列的组合必须唯一，那么联合索引是实现这一要求的理想选择‌。
3.‌提高查询效率‌：联合索引可以有效减少数据库的扫描次数，当查询条件包含联合索引的所有列时，可以利用索引直接定位到目标记录，而无需回表查询，从而显著提高查询效率‌。
4.降低索引维护开销‌：维护多个单独的索引需要较高的开销，而联合索引通过整合多个列到一个索引中，降低了索引的维护成本。当对表中的数据进行增加、删除和修改时，联合索引的维护效率通常高于多个单独索引‌。

## 37.什么是回表？

回表指的是无法直接从索引里获取完整的结果，需要根据索引中的记录再回到原表里查找完整的行数据，这个过程就称为回表查询‌。

## 38.什么情况下会触发回表？

例如，假设有一个员工表（employees），其中有主键id、姓名name和年龄age三个字段，且在name字段上建立了非聚簇索引。
1.查询的字段不在索引中‌：
如果查询语句中需要返回的列不在索引列上，即使通过索引定位了相关行，仍然需要回表获取其他列的值。因为非聚簇索引中只包含了索引列的副本以及指向对应主键的引用，查询需要通过回表才能获取完整的行数据。
例如：当执行查询SELECT * FROM employees WHERE name='张三’时，MySQL会首先通过name索引找到满足条件的主键id值。由于查询的字段中除了name之外的其他列数据（如id和age），而这些数据并不能从非聚簇索引中获取，所以需要通过主键id回到聚簇索引中去查找完整的员工数据。
2.查询的条件字段使用了非索引列‌：
如果查询条件（WHERE子句）中使用了非索引列，那么在通过索引定位到数据行后，MySQL还需要到主键索引中查找对应的数据行。
例如：当执行查询SELECT id,name FROM employees WHERE name=‘张三’ and age=18时，假设表中有100条name为张三age不同的数据，首先可以在索引中找到这100条数据的id和name的值，但是还要找到具体age=18的数据，就必须通过主键id回到聚簇索引中去找出age=18的数据了。

## 39.如何避免回表？

1.使用覆盖索引‌：
覆盖索引是指索引中包含了查询所需的所有列，这样查询时就可以直接从索引中获取数据，而无需回表。例如，如果查询经常需要获取name和age列的数据，可以创建一个包含这两列的覆盖索引‌。
2.优化查询语句‌：
尽量减少SELECT *的使用，只选择查询实际需要的列。这样可以减少不必要的数据读取，也可能避免回表操作‌。
确保查询条件的字段被索引。如果查询条件涉及多个字段，最好为这些字段创建复合索引，以便查询能够完全通过索引来满足，而无需回表‌。


## 40.为什么要创建索引呢？

因为，创建索引可以大大提高系统的性能。
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
第二，可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。
第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
第四，在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

## 41.为什么不对表中的每一个列创建一个索引呢？

第一，创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。
第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

## 42.应该在哪些列上创建索引？

在经常需要搜索的列上，可以加快搜索的速度；
在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；
在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

## 43.应该避免在哪些列上创建索引？

第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因 为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
第二，对于那 些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
第四，当修改性能远远大于检索性能时，不应该创建索 引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因 此，当修改性能远远大于检索性能时，不应该创建索引。

## 44.散列索引是什么？

通过散列函数来定位的一种索引，不过很少有单独使用散列索引的，反而是散列文件组织用的比较多。
散列文件组织就是根据一个键通过散列计算把对应的记录都放到同一个槽中，这样的话相同的键值对应的记录就一定是放在同一个文件里了，也就减少了文件读取的次数，提高了效率。
散列索引呢就是根据对应键的散列码来找到最终的索引项的技术，其实和B树就差不多了，也就是一种索引之上的二级辅助索引，散列索引都是二级或更高级的稀疏索引，否则桶就太多了，效率也不会很高。

## 45.位图索引是什么？

位图索引是一种针对多个字段的简单查询设计一种特殊的索引，适用范围比较小，只适用于字段值固定并且值的种类很少的情况，比如性别，只能有男和女，或者级别，状态等等，并且只有在同时对多个这样的字段查询时才能体现出位图的优势。
位图的基本思想就是对每一个条件都用0或者1来表示，如有5条记录，性别分别是男，女，男，男，女，那么如果使用位图索引就会建立两个位图，对应男的10110和对应女的01001,这样做有什么好处呢，就是如果同时对多个这种类型的字段进行and或or查询时，可以使用按位与和按位或来直接得到结果了。

## 46.用通俗易懂的话介绍聚集索引和非聚集索引。

其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。
我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。
如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。
我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。
通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。


## 47.为什么用B+树而不用B树，B+树有什么优势？

（1）IO代价更低。B+树由于非叶子节点中不存放data，因此可以存放更多的索引值（单个大节点的容量固定，每个小单位size变小了），从而使得树的高度更低，磁盘IO次数更少。
（2）查询效率稳定。B+树由于所有data都放在叶子节点中，因此每次查询都要走完整的根节点到叶子节点的路径，所有查询的路径长度相同，查询效率更加稳定。
（3）更利于范围查询。B+树叶子节点之间有指针，注意是双向的指针，更利于范围查询。

## 48.分析索引对于insert操作的性能影响是什么？

insert的过程是，先把数据插入到表中，然后再把数据插入到相关索引中，如果这个表有5个索引，那么就得维护这5个索引，不管这个插入的数据是否为NULL值。
所以，索引个数越多，对于insert操作来说，维护的成本就越大，插入一条数据的速度也就越慢。
如果发现插入速度很慢，可以检查一下是否这个表的索引太多了。
把数据插入索引的过程中，为了维护索引中字段的顺序，会先在索引中查找这个值，如果能找到，就把这个值查到后面空闲的地方，如果没有找到，就先把值加入到叶子节点，然后在分支节点中新增这个值 和 指向叶子节点的指针（就是一个地址）。
在这个过程中，如果某个页满了，还要新申请一个空的页，把满的页拆分开，把一半的索引数据放到空闲页中，而且为了保证数据的一致性（这个插入操作是并发的，可能有几十上百个线程同时进行），会给相关的索引页加上闩锁（一种更低级别的内存锁）。
如此看来，这个过程的开销是很大的。

## 49.分析索引对于delete操作的性能影响是什么？

delete操作刚好和isnert相反，当删除一条数据时，会把这条数据涉及到的多个索引中的数据删除。
比如：A表包含字段 ID，name，age，memo，biz_date，storeID，employeeID，update_date，等字段，在name、age、biz_date、storeID、employeeID字段上分别创建了索引，也就是总共有5个索引。
现在运行 delete from A where ID = 100
就得把ID=100的这条数据，在各个索引中删掉，开销要比insert小。


## 50.分析索引对于update操作的性能影响是什么？

这个操作不同于insert，delete，只有当update的这个字段，涉及到索引时，才需要维护索引，相对来说开销要小一些。比如：update A set memo=‘备注信息’ where ID = 100，因为更新的memo字段上并没有索引，所以不需要维护索引，而update A set storeID=12345 where ID = 100，只需要更新storeID字段的索引，其他4个索引不需要维护。

## 51.索引过多对操作有什么影响？

1. 写操作性能下降
插入（INSERT）、更新（UPDATE）、删除（DELETE）等写操作会因为索引的增多而变得更为耗时，因为每次写操作都需要同步更新索引，特别是在频繁写操作的情况下。
2. 存储空间占用增加
每个索引都需要占用一定的存储空间，当索引过多时，会占用大量的存储空间，增加数据库的整体存储需求。
3. 查询性能下降
虽然索引可以加速查询操作，但过多的索引可能会导致索引的失效，使得数据库优化器很难选择到最合适的索引，从而导致查询性能下降。此外，索引过多也可能导致索引之间相互竞争，加剧查询性能下降。
4. 索引维护成本增加
随着索引数量的增加，数据库的索引维护成本也会相应增加。维护成本包括索引的创建、更新、重建和删除等操作，可能需要消耗较多的系统资源和时间。
5. 索引选择困难
当存在大量的索引时，数据库优化器在选择最佳的索引时可能会变得更加困难，这可能导致查询执行计划的选择不够有效，进而影响查询性能。

## 52.常见索引分为几种？

1、普通索引，基本的索引，没有任何限制，用于加速查询，数据可以重复CREATE INDEX indexName（索引名） ON mytable（表名）(username字段名(length长度一般全文索引使用));
2、组合索引，指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用
CREATE INDEX index_name ON table_name (column1, column2, ...);
3、全文索引，用来查找文本中的关键字
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)
4、唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
CREATE UNIQUE INDEX indexName ON mytable(username(length))或者ALTER table mytable ADD UNIQUE indexName (username(length))
5、主键索引，特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。也就是在唯一索引的基础上相应的列必须为主键
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)
6、聚集索引：有时也称为主键索引（但二者又不能等同）在聚集索引里，表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每张表只能有一个聚集索引，原因很简单，因为数据行本身只能按一个顺序存储。
7、非聚集索引：非聚集索引也称为二级索引或者辅助索引，对于非聚集索引，数据库会有单独的存储空间来存放。非聚集索引在查找的时候要经过两个步骤，需要先搜索非聚集索引的B+Tree，这个B+Tree的叶子结点存储的不是完整的数据行，而是主键值，当我们搜索完成后得到主键的值，然后拿着主键值再去搜索主键索引的B+Tree，就可以获取到一行完整的数据。一系列的普通索引都可以归纳到非聚集索引，如：普通索引、唯一索引、全文索引；

## 53.索引建立的原则是什么？

哪些需要建立索引：
1、在经常需要搜索的列上，可以加快搜索的速度；
2、在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
3、在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
4、在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；
5、在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
6、在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
哪些不建议建立索引：
1、对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
2、对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，
在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，
并不能明显加快检索速度。
3、对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么
相当大，要么取值很少。

## 54.主键索引就是聚集索引吗？

不是。当我们基于 InnoDB 引擎创建一张表的时候，都会创建一个聚集索引，每张表都有唯一的聚集索引：
1、如果这张表定义了主键索引，那么这个主键索引就作为聚集索引。
2、如果这张表没有定义主键索引，那么该表的第一个唯一非空索引作为聚集索引。
3、如果这张表也没有唯一非空索引，那么 InnoDB 内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个 6 个字节的列，该列的值会随着数据的插入自增。
对于一张表来说，聚集索引只能有一个，因为数据真实的物理存储顺序就是按照聚集索引存储的。主键是表中的一个字段或多个字段，用来唯一地标识表中的一条记录。唯一性是主键最主要的特性。主键的创建必须依赖于索引，默认创建的是聚集索引。也可以在建表时人为修改主键为非聚集索引，聚集索引适合大数据量，少数内容不同的列，非聚集索引适合大数据量，多数内容不同的列

## 55.什么是最左匹配原则？

最左前缀匹配原则，非常重要的原则，建立一个索引，对于索引中的字段，会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。'='和'in'可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，数据库的查询优化器会帮你优化成索引可以识别的形式

## 56.单列索引与组合索引哪个效率更高？

如果我们的查询where条件只有一个，我们完全可以用单列索引，这样的查询速度较快。如果我们的业务场景是需要经常查询多个组合列，不要试图分别基于单个列建立多个单列索引（因为虽然有多个单列索引，但是MySQL只能用到其中的那个它认为似乎最有效率的单列索引）。这是因为当SQL语句所查询的列，全部都出现在组合索引中时，此时由于只需要查询索引块即可获得所有数据，当然比使用多个单列索引要快得多。

## 57.数据库索引的工作原理是什么？

可以概括为以下几个步骤：
索引创建：数据库管理员指定哪些列或列组合来创建索引。
索引构建：数据库管理系统扫描表中的数据，为索引列的值和对应数据记录的指针建立映射关系。
查询执行：当执行查询时，数据库引擎会检查查询条件是否可以利用索引。
索引搜索：如果存在合适的索引，数据库将在索引中查找满足条件的数据，并利用指针迅速定位到实际数据。
数据检索：数据库使用索引中的指针来高效地检索出所需数据。

## 58.B+树是什么？

B+树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。

## 59.B+树的定义是什么？

B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下: 
(1)每个结点至多有m个子女； 
(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女； 
(3)有k个子女的结点必有k个关键字。 
B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。 

## 60.B+树的节点结构是什么？

在 B+ 树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的序数（order）是m ，则除了根之外的每个节点都包含最少 个元素最多 m-1 个元素，对于任意的节点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。因为所有叶子都在相同的高度上，节点通常不包含确定它们是叶子还是内部节点的方式。
每个内部节点的元素充当分开它的子树的分离值。例如，如果内部节点有三个子节点（或子树）则它必须有两个分离值或元素a1和a2。在最左子树中所有的值都小于等于a1，在中间子树中所有的值都在a1和a2之间((a1，a2]），而在最右子树中所有的值都大于a2。

## 61.B+树的查找方式是什么？

查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。

## 62.B+树的插入方式是什么？

节点要处于违规状态，它必须包含在可接受范围之外数目的元素。
1.首先，查找要插入其中的节点的位置。接着把值插入这个节点中。
2.如果没有节点处于违规状态则处理结束。
3.如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。

## 63.B+树的删除方式是什么？

1.首先，查找要删除的值。接着从包含它的节点中删除这个值。
2.如果没有节点处于违规状态则处理结束。
3.如果节点处于违规状态则有两种可能情况：
a.它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。
b.它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。